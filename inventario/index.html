<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="manifest" href="/inventario/manifest.json">
  <title>Sistema de Inventario CRUD</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0;background:#f5f7ff;color:#222}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:#fff;border-bottom:1px solid #e6e9fb}
    .title{display:flex;gap:12px;align-items:center}
    .connectionStatus{font-size:14px;color:#666}
    .header-actions{display:flex;gap:8px;align-items:center}
    button{background:#667eea;color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
    input[type=file]{display:none}
    main{padding:16px}
    .card{background:#fff;padding:12px;border-radius:8px;box-shadow:0 1px 2px rgba(0,0,0,0.04);margin-bottom:12px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px solid #f0f2ff}
    .actions button{margin-right:6px}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Sistema de Inventario</h1>
      <div id="connectionStatus" class="connectionStatus">Comprobando conexión...</div>
    </div>
    <div class="header-actions">
      <button id="installBtn" style="display:none">Instalar PWA</button>
      <button id="backupBtn">Backup</button>
      <label for="restoreInput" style="background:#fff;color:#667eea;padding:6px 10px;border-radius:6px;border:1px solid #667eea;cursor:pointer">Restaurar</label>
      <input id="restoreInput" type="file" accept="application/json">
    </div>
  </header>

  <main>
    <section class="card">
      <h2>Usuarios (SQLite)</h2>
      <form id="userForm">
        <input type="hidden" id="userId">
        <input id="userName" placeholder="Nombre" required>
        <input id="userEmail" placeholder="Email" required>
        <input id="userRole" placeholder="Rol">
        <button type="submit">Guardar</button>
      </form>
      <div id="usersList"></div>
    </section>

    <section class="card">
      <h2>Equipos (IndexedDB)</h2>
      <p>La gestión de equipos sigue usando IndexedDB como antes.</p>
      <div id="equiposList"></div>
    </section>

    <section class="card">
      <h2>Asignaciones (IndexedDB)</h2>
      <p>Las asignaciones siguen en IndexedDB.</p>
      <div id="asignacionesList"></div>
    </section>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
  <script>
    // ------- Connection status -------
    const connEl = document.getElementById('connectionStatus');
    function updateOnlineStatus(){
      connEl.textContent = navigator.onLine ? 'Conectado' : 'Offline';
      connEl.style.color = navigator.onLine ? '#0a8a0a' : '#b33';
    }
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();

    // ------- Service worker registration -------
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/inventario/service-worker.js')
        .then(reg => console.log('Service Worker registrado', reg))
        .catch(err => console.warn('Error SW', err));
    }

    // ------- PWA install prompt handling -------
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'inline-block';
    });
    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log('User choice', outcome);
      deferredPrompt = null;
      installBtn.style.display = 'none';
    });

    // ------- IndexedDB helpers for equipos/asignaciones and old usuarios store -------
    function openAppDB(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open('InventarioDB', 1);
        req.onupgradeneeded = (ev) => {
          const db = ev.target.result;
          if (!db.objectStoreNames.contains('usuarios')) db.createObjectStore('usuarios', { keyPath: 'id', autoIncrement: true });
          if (!db.objectStoreNames.contains('equipos')) db.createObjectStore('equipos', { keyPath: 'id', autoIncrement: true });
          if (!db.objectStoreNames.contains('asignaciones')) db.createObjectStore('asignaciones', { keyPath: 'id', autoIncrement: true });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // separate DB for sqlite binary storage as requested
    function openSqliteStore(){
      return new Promise((resolve, reject) => {
        const r = indexedDB.open('InventarioSQLite', 1);
        r.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('sqlite')) db.createObjectStore('sqlite');
        };
        r.onsuccess = () => resolve(r.result);
        r.onerror = () => reject(r.error);
      });
    }

    async function saveSqliteBinary(uint8arr){
      const db = await openSqliteStore();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('sqlite', 'readwrite');
        const store = tx.objectStore('sqlite');
        const req = store.put(uint8arr, 'db');
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }
    async function loadSqliteBinary(){
      const db = await openSqliteStore();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('sqlite', 'readonly');
        const store = tx.objectStore('sqlite');
        const req = store.get('db');
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // ------- SQL.js initialization and SQLite adapter for usuarios -------
    let SQL;
    let sqlDb; // SQL.Database instance
    async function initSqlJSAndDB(){
      if (!window.initSqlJs) {
        console.warn('sql.js script not loaded');
        return;
      }
      SQL = await window.initSqlJs({ locateFile: filename => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${filename}` });
      const binary = await loadSqliteBinary();
      if (binary) {
        try {
          sqlDb = new SQL.Database(new Uint8Array(binary));
          console.log('SQLite DB cargada desde IndexedDB');
        } catch (err) {
          console.error('Error al abrir la DB desde IndexedDB', err);
          sqlDb = new SQL.Database();
          await setupSqliteSchemaAndMigrate();
        }
      } else {
        sqlDb = new SQL.Database();
        await setupSqliteSchemaAndMigrate();
      }
      renderUsers();
    }

    async function setupSqliteSchemaAndMigrate(){
      // create usuarios table if not exists
      sqlDb.run(`CREATE TABLE IF NOT EXISTS usuarios (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        nombre TEXT,
        email TEXT,
        rol TEXT
      );`);
      // migrate existing usuarios from IndexedDB (if any)
      const appDb = await openAppDB();
      const tx = appDb.transaction('usuarios','readonly');
      const store = tx.objectStore('usuarios');
      const req = store.getAll();
      req.onsuccess = async () => {
        const rows = req.result || [];
        const insert = sqlDb.prepare('INSERT INTO usuarios (nombre,email,rol) VALUES (?,?,?)');
        sqlDb.run('BEGIN TRANSACTION');
        for (const r of rows){
          insert.run([r.nombre||r.name||'', r.email||'', r.rol||r.role||'']);
        }
        sqlDb.run('COMMIT');
        try{ insert.free(); } catch(e){}
        const exported = sqlDb.export();
        await saveSqliteBinary(exported);
        console.log('Migración de usuarios a SQLite completada:', rows.length);
        renderUsers();
      };
      req.onerror = () => {
        console.warn('No hay usuarios para migrar o error al leer');
        const exported = sqlDb.export();
        await saveSqliteBinary(exported);
      };
    }

    // CRUD usuario usando SQLite
    function getAllUsersFromSQLite(){
      try{
        const res = sqlDb.exec('SELECT id,nombre,email,rol FROM usuarios ORDER BY id DESC');
        if (!res || res.length === 0) return [];
        const values = res[0].values;
        return values.map(r => ({id:r[0], nombre:r[1], email:r[2], rol:r[3]}));
      }catch(e){console.error(e);return []}
    }

    async function addUserToSQLite(data){
      const stmt = sqlDb.prepare('INSERT INTO usuarios (nombre,email,rol) VALUES (?,?,?)');
      stmt.run([data.nombre,data.email,data.rol]);
      try{ stmt.free(); }catch(e){}
      const exported = sqlDb.export();
      await saveSqliteBinary(exported);
      renderUsers();
    }
    async function updateUserInSQLite(id,data){
      const stmt = sqlDb.prepare('UPDATE usuarios SET nombre=?,email=?,rol=? WHERE id=?');
      stmt.run([data.nombre,data.email,data.rol,id]);
      try{ stmt.free(); }catch(e){}
      const exported = sqlDb.export();
      await saveSqliteBinary(exported);
      renderUsers();
    }
    async function deleteUserInSQLite(id){
      const stmt = sqlDb.prepare('DELETE FROM usuarios WHERE id=?');
      stmt.run([id]);
      try{ stmt.free(); }catch(e){}
      const exported = sqlDb.export();
      await saveSqliteBinary(exported);
      renderUsers();
    }

    // ------- UI bindings for usuarios -------
    const userForm = document.getElementById('userForm');
    userForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const id = document.getElementById('userId').value;
      const nombre = document.getElementById('userName').value.trim();
      const email = document.getElementById('userEmail').value.trim();
      const rol = document.getElementById('userRole').value.trim();
      if (!nombre || !email) return alert('Nombre y email son obligatorios');
      if (id) {
        await updateUserInSQLite(parseInt(id,10), {nombre,email,rol});
      } else {
        await addUserToSQLite({nombre,email,rol});
      }
      userForm.reset();
      document.getElementById('userId').value = '';
    });

    function renderUsers(){
      const users = getAllUsersFromSQLite();
      const container = document.getElementById('usersList');
      if (!container) return;
      if (users.length === 0){ container.innerHTML = '<p>No hay usuarios.</p>'; return; }
      let html = '<table><thead><tr><th>ID</th><th>Nombre</th><th>Email</th><th>Rol</th><th>Acciones</th></tr></thead><tbody>';
      users.forEach(u => {
        html += `<tr><td>${u.id}</td><td>${escapeHtml(u.nombre)}</td><td>${escapeHtml(u.email)}</td><td>${escapeHtml(u.rol||'')}</td><td class="actions"><button onclick="editUser(${u.id})">Editar</button><button onclick="delUser(${u.id})">Borrar</button></td></tr>`;
      });
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // expose edit/delete for inline handlers
    window.editUser = function(id){
      const users = getAllUsersFromSQLite();
      const u = users.find(x=>x.id===id);
      if (!u) return alert('Usuario no encontrado');
      document.getElementById('userId').value = u.id;
      document.getElementById('userName').value = u.nombre;
      document.getElementById('userEmail').value = u.email;
      document.getElementById('userRole').value = u.rol;
    };
    window.delUser = function(id){
      if (!confirm('¿Borrar usuario?')) return;
      deleteUserInSQLite(id);
    };

    function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }

    // ------- Backup & Restore -------
    document.getElementById('backupBtn').addEventListener('click', async ()=>{
      // export sqlite binary
      const sqliteBinary = await loadSqliteBinary();
      // get equipos and asignaciones from app DB
      const appDb = await openAppDB();
      const tx = appDb.transaction(['equipos','asignaciones'],'readonly');
      const equiposReq = tx.objectStore('equipos').getAll();
      const asignReq = tx.objectStore('asignaciones').getAll();
      equiposReq.onsuccess = () => {
        asignReq.onsuccess = async () => {
          const payload = {
            sqlite: sqliteBinary ? arrayBufferToBase64(sqliteBinary) : null,
            equipos: equiposReq.result || [],
            asignaciones: asignReq.result || []
          };
          const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'inventario-backup-'+new Date().toISOString()+'.json';
          a.click();
          URL.revokeObjectURL(url);
        };
      };
    });

    document.getElementById('restoreInput').addEventListener('change', async (e)=>{
      const f = e.target.files[0];
      if (!f) return;
      const text = await f.text();
      let data;
      try{ data = JSON.parse(text); }catch(err){ return alert('Archivo inválido'); }
      // restore equipos and asignaciones
      const appDb = await openAppDB();
      const tx = appDb.transaction(['equipos','asignaciones'],'readwrite');
      const equiposStore = tx.objectStore('equipos');
      const asignStore = tx.objectStore('asignaciones');
      // clear stores and put new
      const clearEquip = equiposStore.clear();
      const clearAsign = asignStore.clear();
      clearEquip.onsuccess = () => {
        (data.equipos||[]).forEach(item => equiposStore.put(item));
      };
      clearAsign.onsuccess = () => {
        (data.asignaciones||[]).forEach(item => asignStore.put(item));
      };
      tx.oncomplete = async ()=>{
        // restore sqlite
        if (data.sqlite){
          const u8 = base64ToUint8Array(data.sqlite);
          await saveSqliteBinary(u8);
          // reload sqlDb from saved binary
          sqlDb = SQL.Database(new Uint8Array(u8));
          renderUsers();
        }
        alert('Restauración completada');
      };
    });

    function arrayBufferToBase64(buf){
      let binary = '';
      const bytes = new Uint8Array(buf);
      const len = bytes.byteLength;
      for (let i=0;i<len;i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function base64ToUint8Array(base64){
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i);
      return bytes;
    }

    // ------- Equipos / Asignaciones simple renderers (IndexedDB) -------
    async function renderEquiposAndAsignaciones(){
      const db = await openAppDB();
      const tx = db.transaction(['equipos','asignaciones'],'readonly');
      const equiposReq = tx.objectStore('equipos').getAll();
      const asignReq = tx.objectStore('asignaciones').getAll();
      equiposReq.onsuccess = () => {
        const out = document.getElementById('equiposList');
        const list = equiposReq.result || [];
        if (list.length===0) out.innerHTML='<p>No hay equipos.</p>'; else out.innerHTML = '<ul>'+list.map(i=>`<li>${escapeHtml(i.name||i.nombre||'Equipo')}</li>`).join('')+'</ul>';
      };
      asignReq.onsuccess = () => {
        const out = document.getElementById('asignacionesList');
        const list = asignReq.result || [];
        if (list.length===0) out.innerHTML='<p>No hay asignaciones.</p>'; else out.innerHTML = '<ul>'+list.map(i=>`<li>${escapeHtml(i.equipo||i.equipoId||'')} -> ${escapeHtml(i.usuario||i.usuarioId||'')}</li>`).join('')+'</ul>';
      };
    }

    // init everything
    window.addEventListener('load', async ()=>{
      await initSqlJSAndDB();
      renderEquiposAndAsignaciones();
    });

  </script>
</body>
</html>
