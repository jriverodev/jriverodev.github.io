<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RCT Animated Peeps</title>
    <style>
        body { 
            display: flex; flex-direction: column; align-items: center; 
            background: #2c3e50; color: white; font-family: sans-serif; 
            margin: 0; padding: 10px; touch-action: none; 
        }
        canvas { 
            border: 2px solid #34495e; background: #27ae60; 
            width: 90vw; height: 90vw; max-width: 400px; max-height: 400px;
            touch-action: none; image-rendering: pixelated; /* 隆IMPORTANTE para sprites! */
        }
        .controls { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; 
            width: 90vw; max-width: 400px; margin-bottom: 10px; 
        }
        button { 
            padding: 15px 5px; font-size: 14px; border: none; 
            border-radius: 8px; color: white; font-weight: bold; cursor: pointer;
        }
        .btn-mode { background: #7f8c8d; border: 3px solid transparent; }
        .btn-mode.active { border-color: #f1c40f; background: #34495e; }
        .btn-spawn { background: #2ecc71; grid-column: span 2; }
        #count { margin-top: 5px; font-weight: bold; }
    </style>
</head>
<body>

    <div class="controls">
        <button id="btnCamino" class="btn-mode active" onclick="setMode('camino')"> CAMINO</button>
        <button id="btnAtraccion" class="btn-mode" onclick="setMode('atraccion')"> ATRACCIN</button>
        <button class="btn-spawn" onclick="spawnPeeps(10)">+10 VISITANTES</button>
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>
    
    <div id="count">Visitantes: 0</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 40;
        const COLS = 10;
        const ROWS = 10;

        let grid = Array(COLS).fill().map(() => Array(ROWS).fill(0));
        let attraction = null;
        let peeps = [];
        let currentMode = 'camino';

        // Cargar el spritesheet del Peep
        const peepSpriteSheet = new Image();
        peepSpriteSheet.src = 'peep_walk.png'; // Aseg煤rate de que esta ruta sea correcta
        const PEEP_SPRITE_WIDTH = 32; // Ancho de un solo frame en la imagen
        const PEEP_SPRITE_HEIGHT = 32; // Alto de un solo frame en la imagen
        const PEEP_ANIM_FRAMES = 4; // N煤mero total de frames en el spritesheet

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnCamino').classList.toggle('active', mode === 'camino');
            document.getElementById('btnAtraccion').classList.toggle('active', mode === 'atraccion');
        }

        class Peep {
            constructor(x, y) {
                this.gridX = x; this.gridY = y;
                this.pixelX = x * TILE_SIZE + TILE_SIZE/2;
                this.pixelY = y * TILE_SIZE + TILE_SIZE/2;
                this.targetGridX = x; this.targetGridY = y;
                this.isMoving = false;
                this.timerAtraccion = 0;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`; // El color ya no se usar谩 para el cuerpo, pero se mantiene por si acaso
                
                // Variables de animaci贸n
                this.currentFrame = 0;
                this.animTimer = 0;
                this.animSpeed = 10; // Cambiar de frame cada 10 updates (m谩s bajo = m谩s r谩pido)
            }

            update() {
                if (this.timerAtraccion > 0) {
                    this.timerAtraccion--;
                } else if (!this.isMoving) {
                    this.decidirSiguientePaso();
                    // Reiniciar animaci贸n cuando se detiene o cambia de direcci贸n
                    this.currentFrame = 0; 
                    this.animTimer = 0;
                } else {
                    this.moverSuave();
                    this.updateAnimation(); // Actualizar frame de animaci贸n
                }
                this.dibujar();
            }

            updateAnimation() {
                this.animTimer++;
                if (this.animTimer >= this.animSpeed) {
                    this.currentFrame = (this.currentFrame + 1) % PEEP_ANIM_FRAMES;
                    this.animTimer = 0;
                }
            }

            decidirSiguientePaso() {
                if (attraction && Math.abs(this.gridX - attraction.x) <= 1 && Math.abs(this.gridY - attraction.y) <= 1) {
                    if (Math.random() > 0.98) {
                        this.timerAtraccion = 100;
                        return;
                    }
                }
                const dirs = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].sort(()=>Math.random()-0.5);
                for (let d of dirs) {
                    let nX = this.gridX + d.x, nY = this.gridY + d.y;
                    if (nX >= 0 && nX < COLS && nY >= 0 && nY < ROWS && grid[nX][nY] === 1) {
                        this.targetGridX = nX; this.targetGridY = nY;
                        this.isMoving = true;
                        break;
                    }
                }
            }

            moverSuave() {
                const destX = this.targetGridX * TILE_SIZE + TILE_SIZE/2;
                const destY = this.targetGridY * TILE_SIZE + TILE_SIZE/2;
                this.pixelX += (destX - this.pixelX) * 0.15;
                this.pixelY += (destY - this.pixelY) * 0.15;
                if (Math.abs(destX - this.pixelX) < 1 && Math.abs(destY - this.pixelY) < 1) { // Ajustado a 1 para mejor precisi贸n
                    this.pixelX = destX; this.pixelY = destY;
                    this.gridX = this.targetGridX; this.gridY = this.targetGridY;
                    this.isMoving = false;
                }
            }

            dibujar() {
                if (this.timerAtraccion > 0) return; // Si est谩 en la atracci贸n, no se dibuja

                // Calcular la posici贸n del frame en el spritesheet
                const sx = this.currentFrame * PEEP_SPRITE_WIDTH;
                const sy = 0; // Si hubiera varias filas de animaciones, cambiar铆amos esto

                // Dibujar el trozo del spritesheet en la posici贸n del peep
                ctx.drawImage(
                    peepSpriteSheet,
                    sx, sy, PEEP_SPRITE_WIDTH, PEEP_SPRITE_HEIGHT, // Fuente (recorte del spritesheet)
                    this.pixelX - PEEP_SPRITE_WIDTH / 2, // Posici贸n X del dibujo (centrado)
                    this.pixelY - PEEP_SPRITE_HEIGHT / 2, // Posici贸n Y del dibujo (centrado)
                    PEEP_SPRITE_WIDTH, PEEP_SPRITE_HEIGHT // Tama帽o del dibujo en el canvas
                );
            }
        }

        function handleInput(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor(((clientX - rect.left) * scaleX) / TILE_SIZE);
            const y = Math.floor(((clientY - rect.top) * scaleY) / TILE_SIZE);

            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                if (currentMode === 'camino') grid[x][y] = 1;
                else attraction = {x, y};
            }
        }

        canvas.addEventListener('touchstart', handleInput);
        canvas.addEventListener('mousedown', handleInput);

        function spawnPeeps(amount) {
            let paths = [];
            for(let x=0; x<COLS; x++) for(let y=0; y<ROWS; y++) if(grid[x][y] === 1) paths.push({x,y});
            if(paths.length === 0) return alert("隆Dibuja un camino primero!");
            for(let i=0; i<amount; i++) {
                let p = paths[Math.floor(Math.random()*paths.length)];
                peeps.push(new Peep(p.x, p.y));
            }
            document.getElementById('count').innerText = `Visitantes: ${peeps.length}`;
        }

        function drawWorld() {
            for (let x = 0; x < COLS; x++) {
                for (let y = 0; y < ROWS; y++) {
                    if (grid[x][y] === 1) {
                        ctx.fillStyle = "#bdc3c7";
                        ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                    ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    ctx.strokeRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
            if (attraction) {
                ctx.font = "30px Arial";
                ctx.fillText("", attraction.x * TILE_SIZE + 5, attraction.y * TILE_SIZE + 32);
            }
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            peeps.forEach(p => p.update());
            requestAnimationFrame(loop);
        }

        // Asegurarse de que el spritesheet se cargue antes de empezar el loop del juego
        peepSpriteSheet.onload = () => {
            loop();
        };
        // En caso de error al cargar la imagen
        peepSpriteSheet.onerror = () => {
            console.error("Error al cargar la imagen 'peep_walk.png'. Aseg煤rate de que est茅 en la misma carpeta.");
            // Si la imagen no carga, podemos iniciar el loop sin sprites (dibujar c铆rculos como antes)
            // o mostrar un mensaje de error al usuario.
            // Por ahora, iniciamos el loop para que al menos se vea algo.
            loop(); 
        };
    </script>
</body>
</html>
