<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RCT Ultra-Isometric Pixel Art</title>
    <style>
        body { 
            display: flex; flex-direction: column; align-items: center; 
            background: #2c3e50; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; padding: 0; overflow: hidden; touch-action: none;
        }
        #ui-layer {
            position: absolute; top: 10px; width: 90%; max-width: 400px;
            z-index: 10; pointer-events: none;
        }
        .stat-card {
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 12px;
            border-bottom: 4px solid #f1c40f; display: flex; justify-content: space-between;
        }
        canvas { 
            image-rendering: pixelated; width: 100vw; height: 100vh;
        }
        .controls {
            position: absolute; bottom: 20px; display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; width: 90%; max-width: 400px; z-index: 10;
        }
        button {
            background: #34495e; color: white; border: none; padding: 12px 5px;
            border-radius: 8px; font-weight: bold; font-size: 10px; border-bottom: 4px solid #2c3e50;
        }
        button.active { background: #f1c40f; color: #000; border-color: #f39c12; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-card">
            <span>üí∞ $<span id="moneyTxt">500</span></span>
            <span>üòä <span id="happyTxt">100</span>%</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        <button id="btnCamino" class="active" onclick="setMode('camino')">CAMINO</button>
        <button id="btnFeria" onclick="setMode('feria')">üé° FERIA</button>
        <button id="btnComida" onclick="setMode('comida')">üçî COMIDA</button>
        <button id="btnBanco" onclick="setMode('banco')">üí∫ BANCO</button>
        <button style="background:#2ecc71" onclick="spawnPeeps(1)">+ VISITANTE</button>
        <button style="background:#3498db" onclick="hireStaff()">+ LIMPIADOR</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        const TILE_W = 60; // Ancho del rombo
        const TILE_H = 30; // Alto del rombo
        const GRID_SIZE = 10;

        let wallet = 500, currentMode = 'camino';
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let buildings = [], peeps = [];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Convertir coordenadas de rejilla a pantalla (Isom√©trica)
        function isoToScreen(mapX, mapY) {
            return {
                x: width / 2 + (mapX - mapY) * (TILE_W / 2),
                y: height / 4 + (mapX + mapY) * (TILE_H / 2)
            };
        }

        function setMode(m) {
            currentMode = m;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            if(document.getElementById('btn'+m.charAt(0).toUpperCase()+m.slice(1)))
                document.getElementById('btn'+m.charAt(0).toUpperCase()+m.slice(1)).classList.add('active');
        }

        class Peep {
            constructor(isStaff = false) {
                this.x = 0; this.y = 0;
                this.targetX = 0; this.targetY = 0;
                this.isMoving = false;
                this.color = isStaff ? "#3498db" : `hsl(${Math.random()*360}, 70%, 50%)`;
                this.anim = 0;
                this.isStaff = isStaff;
            }

            update() {
                if(!this.isMoving) {
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    const d = dirs[Math.floor(Math.random()*4)];
                    const nx = this.x + d.x, ny = this.y + d.y;
                    if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE && grid[nx][ny] === 1) {
                        this.targetX = nx; this.targetY = ny;
                        this.isMoving = true;
                    }
                } else {
                    this.x += (this.targetX - this.x) * 0.1;
                    this.y += (this.targetY - this.y) * 0.1;
                    this.anim += 0.2;
                    if(Math.abs(this.x - this.targetX) < 0.05) {
                        this.x = this.targetX; this.y = this.targetY;
                        this.isMoving = false;
                    }
                }
            }

            draw() {
                const pos = isoToScreen(this.x, this.y);
                const bounce = Math.abs(Math.sin(this.anim)) * 4;
                
                ctx.save();
                ctx.translate(pos.x, pos.y - 5);
                
                // Personaje estilo imagen: Cabeza grande, cuerpo peque√±o, contorno negro
                // Cuerpo
                ctx.fillStyle = "#000"; ctx.fillRect(-6, -12 - bounce, 12, 10);
                ctx.fillStyle = this.color; ctx.fillRect(-5, -11 - bounce, 10, 8);
                // Cabeza
                ctx.fillStyle = "#000"; ctx.fillRect(-8, -26 - bounce, 16, 15);
                ctx.fillStyle = "#ffdbac"; ctx.fillRect(-7, -25 - bounce, 14, 13);
                // Ojos
                ctx.fillStyle = "#000"; ctx.fillRect(2, -20 - bounce, 2, 3);
                
                ctx.restore();
            }
        }

        function drawMap() {
            ctx.clearRect(0, 0, width, height);

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const pos = isoToScreen(x, y);
                    
                    // Dibujar el suelo (Rombo)
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(pos.x + TILE_W / 2, pos.y + TILE_H / 2);
                    ctx.lineTo(pos.x, pos.y + TILE_H);
                    ctx.lineTo(pos.x - TILE_W / 2, pos.y + TILE_H / 2);
                    ctx.closePath();
                    
                    ctx.fillStyle = grid[x][y] === 1 ? "#95a5a6" : "#2ecc71";
                    ctx.fill();
                    ctx.strokeStyle = "rgba(0,0,0,0.1)";
                    ctx.stroke();

                    // Dibujar edificios
                    const b = buildings.find(b => b.x === x && b.y === y);
                    if(b) {
                        ctx.fillStyle = "#000"; ctx.fillRect(pos.x - 10, pos.y - 20, 20, 25);
                        if(b.type === 'feria') ctx.fillStyle = "#e74c3c";
                        else if(b.type === 'comida') ctx.fillStyle = "#f39c12";
                        else ctx.fillStyle = "#7f8c8d";
                        ctx.fillRect(pos.x - 8, pos.y - 18, 16, 20);
                    }
                }
            }
        }

        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            // Simplificaci√≥n: Clic directo en grid para m√≥viles
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - width/2;
            const mouseY = touch.clientY - height/4;
            
            const gx = Math.floor((mouseY / (TILE_H/2) + mouseX / (TILE_W/2)) / 2);
            const gy = Math.floor((mouseY / (TILE_H/2) - mouseX / (TILE_W/2)) / 2);

            if(gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                if(currentMode === 'camino') { grid[gx][gy] = 1; wallet -= 10; }
                else { buildings.push({x: gx, y: gy, type: currentMode}); wallet -= 50; }
                document.getElementById('moneyTxt').innerText = wallet;
            }
        });

        function spawnPeeps(n) { for(let i=0; i<n; i++) peeps.push(new Peep()); }
        function hireStaff() { peeps.push(new Peep(true)); }

        function gameLoop() {
            drawMap();
            // Ordenar peeps por posici√≥n Y para que los de atr√°s no tapen a los de adelante
            peeps.sort((a,b) => (a.x + a.y) - (b.x + b.y));
            peeps.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(gameLoop);
        }

        // Inicializar parque
        grid[0][0] = 1; grid[1][0] = 1; grid[2][0] = 1;
        gameLoop();
    </script>
</body>
    </html>
    
