<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RCT Ultra-Isometric Pro</title>
    <style>
        body { 
            display: flex; flex-direction: column; align-items: center; 
            background: #111; color: white; font-family: 'Arial Black', sans-serif; 
            margin: 0; padding: 0; overflow: hidden; touch-action: none;
        }
        #ui-top {
            position: absolute; top: 0; width: 100%; height: 50px;
            background: linear-gradient(to bottom, #4a4a4a, #222);
            border-bottom: 2px solid #000; display: flex; align-items: center;
            justify-content: space-around; z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .stat { color: #0f0; text-shadow: 1px 1px #000; font-size: 18px; }
        canvas { image-rendering: pixelated; width: 100vw; height: 100vh; background: #2d7d32; }
        .toolbar {
            position: absolute; bottom: 15px; display: flex; gap: 8px;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px; z-index: 100;
        }
        .tool-btn {
            width: 50px; height: 50px; border: 2px solid #fff; border-radius: 5px;
            display: flex; align-items: center; justify-content: center; font-size: 20px;
            background: #555; cursor: pointer;
        }
        .active { background: #f1c40f !important; border-color: #000 !important; }
    </style>
</head>
<body>

    <div id="ui-top">
        <div class="stat">üí∞ $<span id="moneyTxt">1000</span></div>
        <div class="stat">üòä <span id="happyTxt">100</span>%</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="toolbar">
        <div id="btn-camino" class="tool-btn active" onclick="setMode('camino')">üõ£Ô∏è</div>
        <div id="btn-feria" class="tool-btn" onclick="setMode('feria')">üé°</div>
        <div id="btn-comida" class="tool-btn" onclick="setMode('comida')">üçî</div>
        <div id="btn-limpiador" class="tool-btn" style="background:#3498db" onclick="hireStaff()">üßπ</div>
        <div id="btn-peep" class="tool-btn" style="background:#2ecc71" onclick="spawnPeep()">üë§</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        const TILE_W = 64; // Tama√±o RCT cl√°sico
        const TILE_H = 32;
        const GRID_SIZE = 15; // Mapa m√°s grande

        let wallet = 1000, currentMode = 'camino';
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let objects = []; // Edificios y Peeps
        let camera = { x: 0, y: 0 };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            camera.x = width / 2;
            camera.y = height / 4;
        }
        window.addEventListener('resize', resize);
        resize();

        function setMode(m) {
            currentMode = m;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-'+m)?.classList.add('active');
        }

        function toScreen(gx, gy) {
            return {
                x: camera.x + (gx - gy) * (TILE_W / 2),
                y: camera.y + (gx + gy) * (TILE_H / 2)
            };
        }

        class Peep {
            constructor(isStaff = false) {
                this.gx = 0; this.gy = 0;
                this.px = 0; this.py = 0;
                this.targetGX = 0; this.targetGY = 0;
                this.isMoving = false;
                this.color = isStaff ? "#3498db" : `hsl(${Math.random()*360}, 70%, 50%)`;
                this.anim = 0;
                this.isStaff = isStaff;
                this.type = 'peep';
            }

            update() {
                if(!this.isMoving) {
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    const d = dirs[Math.floor(Math.random()*4)];
                    const nx = this.gx + d.x, ny = this.gy + d.y;
                    if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE && grid[nx][ny] === 1) {
                        this.targetGX = nx; this.targetGY = ny;
                        this.isMoving = true;
                    }
                } else {
                    this.gx += (this.targetGX - this.gx) * 0.1;
                    this.gy += (this.targetGY - this.gy) * 0.1;
                    this.anim += 0.2;
                    if(Math.abs(this.gx - this.targetGX) < 0.05) {
                        this.gx = this.targetGX; this.gy = this.targetGY;
                        this.isMoving = false;
                    }
                }
            }

            draw() {
                const pos = toScreen(this.gx, this.gy);
                const bounce = Math.abs(Math.sin(this.anim)) * 3;
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                
                // Sombra en el suelo
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.beginPath(); ctx.ellipse(0, 0, 8, 4, 0, 0, Math.PI*2); ctx.fill();

                // CUERPO (Estilo RCT: con volumen)
                ctx.fillStyle = "#000"; ctx.fillRect(-6, -15-bounce, 12, 12); // Borde
                ctx.fillStyle = this.color; ctx.fillRect(-5, -14-bounce, 10, 10);
                
                // CABEZA
                ctx.fillStyle = "#000"; ctx.fillRect(-7, -28-bounce, 14, 14); // Borde
                ctx.fillStyle = "#ffdbac"; ctx.fillRect(-6, -27-bounce, 12, 12);
                
                // Cara (Ojos)
                ctx.fillStyle = "#000"; ctx.fillRect(2, -23-bounce, 2, 3);
                
                ctx.restore();
            }
        }

        function drawTile(gx, gy) {
            const pos = toScreen(gx, gy);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(pos.x + TILE_W/2, pos.y + TILE_H/2);
            ctx.lineTo(pos.x, pos.y + TILE_H);
            ctx.lineTo(pos.x - TILE_W/2, pos.y + TILE_H/2);
            ctx.closePath();

            // Color de la baldosa (C√©sped vs Camino)
            if(grid[gx][gy] === 1) {
                ctx.fillStyle = "#777"; // Camino
                ctx.fill();
                ctx.strokeStyle = "#999"; ctx.stroke();
            } else {
                ctx.fillStyle = "#3a8e3f"; // C√©sped RCT
                ctx.fill();
                // Detalle de hierba
                ctx.fillStyle = "#2d7d32";
                ctx.fillRect(pos.x-2, pos.y+10, 2, 2);
            }
        }

        function drawObject(obj) {
            const pos = toScreen(obj.x, obj.y);
            if(obj.type === 'feria') {
                // Base
                ctx.fillStyle = "#000"; ctx.fillRect(pos.x - 20, pos.y - 40, 40, 45);
                ctx.fillStyle = "#e74c3c"; ctx.fillRect(pos.x - 18, pos.y - 38, 36, 41);
                // Techo inclinado
                ctx.fillStyle = "#c0392b";
                ctx.beginPath(); ctx.moveTo(pos.x-20, pos.y-40); ctx.lineTo(pos.x, pos.y-60); ctx.lineTo(pos.x+20, pos.y-40); ctx.fill();
            } else if(obj.type === 'comida') {
                ctx.fillStyle = "#000"; ctx.fillRect(pos.x - 15, pos.y - 30, 30, 35);
                ctx.fillStyle = "#f39c12"; ctx.fillRect(pos.x - 13, pos.y - 28, 26, 31);
            }
        }

        canvas.onclick = (e) => {
            const mx = e.clientX - camera.x;
            const my = e.clientY - camera.y;
            const gx = Math.floor((my / (TILE_H/2) + mx / (TILE_W/2)) / 2);
            const gy = Math.floor((my / (TILE_H/2) - mx / (TILE_W/2)) / 2);

            if(gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                if(currentMode === 'camino') { grid[gx][gy] = 1; wallet -= 10; }
                else { objects.push({x: gx, y: gy, type: currentMode}); wallet -= 100; }
                document.getElementById('moneyTxt').innerText = wallet;
            }
        };

        function spawnPeep() { objects.push(new Peep()); }
        function hireStaff() { objects.push(new Peep(true)); }

        function render() {
            ctx.clearRect(0,0,width,height);
            
            // 1. Dibujar suelo
            for(let i=0; i<GRID_SIZE; i++) {
                for(let j=0; j<GRID_SIZE; j++) {
                    drawTile(i, j);
                }
            }

            // 2. Dibujar objetos y peeps con orden de profundidad (Z-Sorting)
            let drawList = [...objects].sort((a,b) => {
                let ay = (a.gx !== undefined) ? (a.gx + a.gy) : (a.x + a.y);
                let by = (b.gx !== undefined) ? (b.gx + b.gy) : (b.x + b.y);
                return ay - by;
            });

            drawList.forEach(obj => {
                if(obj instanceof Peep) {
                    obj.update();
                    obj.draw();
                } else {
                    drawObject(obj);
                }
            });

            requestAnimationFrame(render);
        }

        // Crear camino inicial
        for(let i=0; i<5; i++) grid[i][0] = 1;
        render();
    </script>
</body>
</html>
